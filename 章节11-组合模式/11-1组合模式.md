# 组合模式（Composite）

在现实生活中，存在很多“部分-整体”的关系，例如，大学中的部门与学院、总公司中的部门与分公司、学习用品中的书与书包、生活用品中的衣服与衣柜、以及厨房中的锅碗瓢盆等。在软件开发中也是这样，例如，文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。

组合（Composite Pattern）模式的定义：有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性，属于 **结构型设计模式** 。

组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，顶层的节点被称为根节点，根节点下面可以包含树枝节点和叶子节点，树枝节点下面又可以包含树枝节点和叶子节点，树形结构图如下。

![组合模式树形结构图](..\img\5-201019124253553.png)


由上图可以看出，其实根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；而叶子节点与树枝节点在语义上不属于用一种类型。但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。

这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。

组合模式的主要优点有：

1. 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；
2. 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；


其主要缺点是：

1. 设计较复杂，客户端需要花更多时间理清类之间的层次关系；
2. 不容易限制容器中的构件；
3. 不容易用继承的方法来增加构件的新功能；

## 一个基本的目录内容遍历范例

```c++
namespace _nmsp1
{
    // 文件相关的类
    class File
    {
    public:
        // 构造函数
        File(string name):m_sname(name)
        {}
        
        // 显示文件名
        void showName(string lvlstr)    // lvlstr 用来显示层次关系的缩进字符串内容
        {
            std::cout << lvlstr << "[-]" << m_sname << std::endl;
            // '-' 代表是一个文件，属于末端节点（与之对应的 + 代表一个目录）
        }
        
    private:
        string m_sname;     // 文件名
    };
    
    // 目录相关的类
    class Dir
    {
    public:
        Dir(string name) : m_sname(name)
        {}
        
    public:
        // 往目录中增加文件
        void addFile(File* tmpv)
        {
            m_childFile.push_back(tmpv);
        }
        
        // 往目录中增加目录
        void addDir(Dir* tmpv)
        {
            m_childDir.push_back(tmpv);
        }
        
        // 显示目录名(同时也要负责旗下的目录和文件名显示)
        void showName(string lvlstr)
        {
            // 输出本目录名（+代表一个目录）
            std::cout << lvlstr << "[+]" << m_sname << std::endl;
            
            // 输出所包含的文件名
            lvlstr += "────";
            // 本目录中的文件和目录的显示，要缩进一些来显示
            for(auto iter = m_childDir.begin(); iter != m_childDir.end(); ++iter)
            {
                (*iter)->showName(lvlstr);
            }
            
            // 输出所包含的文件名
            for(auto iter = m_childFile.begin(); iter != m_childFile.end(); ++iter)
            {
                (*iter)->showName(lvlstr);
            }
            
        }
        
    private:
        string m_sname; // 目录名
        list<File*> m_childFile;    // 目录中包含的文件列表
        list<Dir*> m_childDir;      // 目录中包含的子目录列表
    };
}
```

main中调用进行测试

```c++
int main()
{
    // 创建一个目录树结构
    _nmsp1::Dir* pdir1 = new _nmsp1::Dir("root");
    _nmsp1::Dir* pdir2 = new _nmsp1::Dir("src");
    _nmsp1::Dir* pdir3 = new _nmsp1::Dir("lib");
    _nmsp1::Dir* pdir4 = new _nmsp1::Dir("net");
    _nmsp1::Dir* pdir5 = new _nmsp1::Dir("commpoment");
    
    _nmsp1::File* file1 = new _nmsp1::File("vue.config.js");
    _nmsp1::File* file2 = new _nmsp1::File("main.ts");
    _nmsp1::File* file3 = new _nmsp1::File("shims-vue.d.ts");
    _nmsp1::File* file4 = new _nmsp1::File("README.md");
    
    _nmsp1::File* file5 = new _nmsp1::File("hello.vue");
    _nmsp1::File* file6 = new _nmsp1::File("world.vue");
    _nmsp1::File* file7 = new _nmsp1::File("plugin.ts");
    _nmsp1::File* file8 = new _nmsp1::File("config.tsx");
    
    _nmsp1::File* file9 = new _nmsp1::File(".bable.rc");
    _nmsp1::File* file10 = new _nmsp1::File("socket.ts");
    _nmsp1::File* file11 = new _nmsp1::File("include.h");
    _nmsp1::File* file12 = new _nmsp1::File("error.ts");
    
    _nmsp1::File* file13 = new _nmsp1::File("index.vue");
    _nmsp1::File* file14 = new _nmsp1::File("big.vue");
    
    pdir5->addFile(file13);
    pdir5->addFile(file14);
    
    pdir2->addDir(pdir5);
    
    pdir4->addFile(file12);
    pdir4->addFile(file11);
    pdir4->addFile(file10);
    
    pdir3->addFile(file9);
    
    pdir2->addFile(file5);
    pdir2->addFile(file6);
    pdir2->addFile(file7);
    pdir2->addFile(file8);
    
    pdir1->addDir(pdir2);
    pdir1->addDir(pdir3);
    pdir1->addDir(pdir4);
    
    pdir1->addFile(file1);
    pdir1->addFile(file2);
    pdir1->addFile(file3);
    pdir1->addFile(file4);
    
    
    // 输出目录结构
    pdir1->showName("┼");
    // ┼[+]root
    // ┼────[+]src
    // ┼────────[+]commpoment
    // ┼────────────[-]index.vue
    // ┼────────────[-]big.vue
    // ┼────────[-]hello.vue
    // ┼────────[-]world.vue
    // ┼────────[-]plugin.ts
    // ┼────────[-]config.tsx
    // ┼────[+]lib
    // ┼────────[-].bable.rc
    // ┼────[+]net
    // ┼────────[-]error.ts
    // ┼────────[-]include.h
    // ┼────────[-]socket.ts
    // ┼────[-]vue.config.js
    // ┼────[-]main.ts
    // ┼────[-]shims-vue.d.ts
    // ┼────[-]README.md
    

    // 内存释放。。。
    return 0;
}
```

当前这个范例有什么问题？

为了输出树形结构，这里我们对目录和文件进行了区分（写了两个类，其实也就是树形结构里的树枝和树叶）,所以，这里就引入组合模式，组合模式就是为了解决在处理这些树形结构的时候，不再需要将叶子和枝干进行区分。而是引入一个新的类，比如这里可以引入一个 FileSystem 文件系统抽象类，然后在该抽象类中提供一个接口。然后让File类和Dir类分别继承自FileSystem抽象类

## 使用组合模式改造目录内容遍历范例

## 引入组合模式（Composite）

## 透明组合模式与安全组合模式

## 其他使用组合模式的场景探讨