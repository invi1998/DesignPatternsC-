# 类设计中的一些技巧

## 优先考虑为成员变量提供访问接口

当需要对成员变量进行访问时，可以使用 Private 来修饰成员变量，然后提供一个public修饰的成员函数作为外接访问该变量的接口。

```c++
namespace _nmsp1
{
    class A1
    {
    public:
        int m_a;
    };
    
    class A2
    {
    public:
        int& getA()
        {
            return m_a;
        }
        
    private:
        int m_a;
    };
    
    
    void func()
    {
        A1 a1obj;
        a1obj.m_a = 10;
        std::cout << a1obj.m_a << std::endl;
        // 10
        A2 a2obj;
        a2obj.getA() = 110;  // 因为getA返回的是一个左值引用，所以这里可以给左值赋值
        std::cout << a2obj.getA() << std::endl;
        // 110
    }
}
```

## 如何避免将父类的虚函数暴露给子类

myfunc函数是myvirfunc函数的一行通道性质的代码。非虚拟接口(Nonvirtual interface，NVI)非虚拟接口不适用于虚析构函数，对于这种普通的虚函数可以使用

```cpp
namespace _nmsp2
{
    class A
    {
    public:
        // 这里的myfunc其实就相当于myvirfunc的一个通道性质的代码
        // 像一个通道一样直接调用虚函数
        void myfunc()
        {
            myvirfunc();
        }
        
        virtual ~A() {}
    
    private:
        virtual void myvirfunc()
        {
            std::cout << "A::myvirfunc()虚函数执行了" << std::endl;
        }
        
    };
    
    class B : public A
    {
    private:
        virtual void myvirfunc()
        {
            std::cout << "B::myvirfunc()虚函数执行了" << std::endl;
        }
        
    };
    
    void func()
    {
        A* pobj = new B();
        pobj->myfunc();
        // B::myvirfunc()虚函数执行了
        
        // 当然如果正常情况下，父类的虚函数没有用private修饰的话，我们是可以正常访问的，不需要通过这个通道
        // pobj->A::myvirfunc();
        
        // 当然，这里就是因为父类不希望自己的 myvirfunc 虚函数被子类调用，所以他这里才使用private修饰
        
        delete pobj;
    }
}
```

如果能将虚函数设置为私有，则优先考虑将其设置为私有函数

## 不要在类的构造函数和析构函数中调用虚函数

如果在父类的构造函数中调用了一个子类的虚函数是无法做到的，因为执行到父类的构造函数时对象的子类部分还没有被构造出来（未成熟对象）。

如果在父类的析构函数中调用了一个子类的虚函数是无法做到的，因为执行到父类的析构函数体时对象的子类部分已经销毁了。

总结：不要在类的构造和析构函数中调用虚函数，在构造和析构函数中，虚函数可能会失去虚函数的作用而被当做普通函数看待。

```c++
namespace _nmsp1
{
    class Anew
    {
    public:
        Anew()
        {
            f1();
        }
        virtual ~Anew()
        {
            f2();
        }
        
        // 定义两个虚函数
        virtual void f1()
        {
            std::cout << "虚函数Anew::f1()执行了" << std::endl;
        }
        
        virtual void f2()
        {
            std::cout << "虚函数Anew::f2()执行了" << std::endl;
        }
        
        void AClassFunc()
        {
            f1();
        }
    };
    
    class Bnew : public Anew
    {
    public:
        Bnew()
        {
            f1();
        }
        
        ~Bnew()
        {
            f2();
        }
        
    public:
        virtual void f1()
        {
            std::cout << "虚函数Bnew::f1()执行了" << std::endl;
        }
        
        virtual void f2()
        {
            std::cout << "虚函数Bnew::f2()执行了" << std::endl;
        }
    };
    
    void func()
    {
        Anew* pnew = new Bnew();
        std::cout << "-----------------begin---------------" << std::endl;
        
        pnew->f1();
        pnew->f2();
        pnew->AClassFunc();
        
        std::cout << "-----------------end---------------" << std::endl;
        
        delete pnew;
        
        // 虚函数Anew::f1()执行了
        // 虚函数Bnew::f1()执行了
        // -----------------begin---------------
        // 虚函数Bnew::f1()执行了
        // 虚函数Bnew::f2()执行了
        // ��函数Bnew::f1()执行了
        // -----------------end---------------
        // 虚函数Bnew::f2()执行了
        // 虚函数Anew::f2()执行了
        
        // 结果中的第一行，展示了类Anew的构造函数中，针对f1虚函数的调用。调用的是类Anew构造函数中的虚函数调用
        // 结果中最后一行，展示了类Anew析构函数中，针对f2（）的调用,实际上调用的是Anew中的虚函数，并不是Bnew中的f2虚函数
        
    }
}
```



## 析构函数的虚与非虚谈

父类的析构函数不一定非得是虚函数，但是单父类指针指向子类对象的时候，或者是父类引用绑定子类对象的时候，这种多态形式的代码存在时，父类是需要写一个public修饰的析构函数的，这样就可以通过对父类的接口来多态的销毁子类对象，否者就可能会造成内存泄漏

nocopyable ，其析构函数就是使用protected修饰的。noncopyable的析构函数不是虚函数

```c++
namespace _nmsp2
{
    class Anew2
    {
    protected:
        ~Anew2()
        {
            
        }
    };
    
    class Bnew2 : public Anew2
    {
    
    };
    
    // 可以看到，仅仅是使用protected修饰析构函数，就达到了如下几个效果（目的）
    void func()
    {
        Anew2 aobj; // 报错
        // 无法创建父类对象
        
        Anew2 *paobj = new Anew2;
        
        delete paobj; // 报错
        // 无法让父类指针指向子类对象（这里表现为只能new，不能delete）
        
        
        Anew2* paobj2 = new Bnew2; 
        
        delete paobj2; // 报错
        
        Bnew2 *pbobj = new Bnew2;
        // 子类指针指向子类对象
        delete pbobj;
        // 也能成功delete
    }
}
```

总结：如果一个父类的析构函数不是虚函数，并且也不利用这个父类创建对象，也不会用到这个父类类型的指针，则应该考虑将该父类的析构函数使用protected进行修饰而非public来用于防止写出错误代码。（增加代码编写安全性，防止误用或者误写），这也正是一些大师所说的，一个类型要做到易于正确使用，难以错误使用。

其实父类的析构函数不是虚函数，本身也就暗示着不会通过父类的接口来多态的销毁子类对象。也暗示着不会用到父类类型的指针。

## 抽象类的模拟

抽象类：至少有一个纯虚函数。不能用来生成对象，它主要是用来定义一些接口规范，纯虚函数，来统一管理子类。或者建立一些供子类参考的接口标准，同时派生出子类，并要求子类实现这些接口规范。

但是有些时候，考虑到找不到合适的纯虚函数，但是又希望能够创建一个有抽象特征的类（不能用来生成对象）

第一种达到模拟抽象类的方法，将该类的构造函数和拷贝构造函数都是用protected来进行修饰。

```c++
namespace _nmsp3
{
    class PVC
    {
    protected:
        PVC() {}    // 构造函数
        
        PVC(const PVC&) {}  // 拷贝构造函数
    };
    
    clas subPVC : public PVC
    {};
    
    // 因为父类的构造函数和拷贝构造函数都使用了protected修饰，这样做就导致没办法生成父类对象，
    // 而只能创建子类subPVC类对象
    void func() 
    {
        subPVC obj1;    // 构造函数
        subPVC obj2(obj1);  // 使用obj1来拷贝构造
    }
}
```

第二种达到模拟抽象类的方法，将抽象类析构函数设置为纯虚函数，并在类外为该纯虚函数定义函数实现。

```c++
namespace _nmsp4
{
    class PVC
    {
    public:
    // 析构函数设置为纯虚函数
        virtual ~PVC() = 0;
    };
    
    // 类外实现类析构函数（纯虚函数绝大部门都是没有实现体的，但是这里纯虚析构函数是个特例）
    // 这里为了释放资源，所以这里要有实现体
    PVC::~PVC()
    {
        
    }
    
    class subPVC : public SVC
    {
    public:
        // 父类中的这个析构函数是虚函数，那么子类中这个不加virtua也是虚函数
        ~subPVC()
        {
            
        }
    };
    
    void func()
    {
        subPVC obj1;    // 析构时，编译器会先执行该类自己的析构函数，再执行父类的析构函数体
        
        PVC *p = new subPVC;
        delete p;   // delete p的时候，同样会先执行该类自己的析构函数，再执行父类的析构函数
    }
}
```

为什么要为纯虚 析构函数定义结构体。因为子类subPVC他的析构函数会隐式的调用父类PVC的析构函数，即便子类sunPVC它没有书写析构函数，编译器也会为子类合成析构函数，并在该析构函数中插入调用父类PVC析构函数的代码。

如果单前类继承一个基类，基类带析构函数，那么编译器就会给单前类和成一个析构函数，这个合成出来的析构函数存在的意义就是因为他要调用基类的析构函数。

第三种：就是将该模拟抽象类的析构函数使用protected来修饰

```c++
namespace _nmsp5
{
    class PVC
    {
    protected:
        ~PVC()
        {
            
        }
    };
    
    class subPVC : public PVC
    {};
    
    void func()
    {
        subPVC obj1;
        subPVC obj2(obj1);
        subPVC* obj3 = new subPVC();
        
        delete obj3;
        
        
        PVC obj4;   // 不可以，报错，不能创建父类对象
        PVC obj5(obj4);  //  也不可以，报错，不能拷贝构造父类对象
        
        PVC *obj5 = new PVC;
        delete obj5;    // 这行报错，不能delete（能new不能delete，也就相当于不能创建对象）
        PVC *obj6 = new subPVC;
        delete obj6;    // 这行报错，也是不能delete
    }
}
```

## 尽量避免隐式类型装换

## 强制类对象不可以或只能在堆上分配内存

### 强制类对象不可以在堆上分配内存

### 强制类对象只可以在堆上分配内存