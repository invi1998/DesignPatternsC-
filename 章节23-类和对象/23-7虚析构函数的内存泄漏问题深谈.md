# 虚析构函数的内存泄漏问题深谈

对于继承关系下的内存泄漏问题，产生的主要原因是父类指针指向子类对象的时候，在delete父类指针的时候，如果父类的析构函数不是虚析构函数的时候，就会导致子类的析构函数不执行。换句话说就是父类对象的指针被销毁了，但是子类对象并没有被销毁，处于一个半销毁状态。

如果一个类 不作为 父类的话，是不应该随便给一个类增加虚析构函数的。尤其是一个类已往没有虚函数的时候，因为一旦增加了虚析构函数，就会导致这个类生成一个虚函数表，同时导致该类对象多出一个虚函数表指针，对于x86平台多出4字节的指针大小，对于x64平台是多出8字节的指针占用。这显然是对内存的一个浪费。所以不需要虚函数的地方不要随便加虚函数。

假设某个程序员在继承第三个提供的类的时候，它并不了解这个第三方类的具体情况，而且这个第三方类也恰恰没有提供虚析构函数。

```c++
namespace _nmsp1
{
    class ThirdPartClass
    {
    public:
    
    };
    
    class B : public ThirdPartClass
    {
    public:
        char* m_p;
        
        B()
        {
            m_p = new char[100];
        }
        
        ~B()
        {
            delete m_p;
        }
    };
    
    void func()
    {
        ThirdPartClass* mb = new B();   // 父类指针指向子类对象
        delete mb;  // 因为父类中并没有提供虚析构函数，所以该行内存释放并不会执行子类的析构函数
        // 所以这里就会造成子类 m_p 这100字节的内存泄漏。
    }
}
```

所以记住：不要随便public继承一个自己不熟悉的类。如果你希望自己提供的类不允许被继承，那么可以使用c++11中提供的final关键字进行修饰。

只有父类指针指向子类对象或者父类引用绑定子类对象的时候，这种多态形式的代码才有必要写一个虚析构函数（一般public修饰）

- 如果子类public继承父类，那么父类指针可以指向子类对象，父类引用也可以绑定子类对象。
- 如果子类private 或者 protected 继承父类，那么父类指针不可以指向子类对象，父类引用也不可以绑定子类对象。
- 如果想让父类指向子类对象，那么就需要使用public继承，同时这个时候父类就需要提供虚析构函数。

总结类中存在虚析构函数的情形

一般如果父类中有其他虚函数，意味着会按照多态的方式来使用该父类，也就是一般会存在父类指针指向子类对象的情形，那么此时父类中应该有一个public修饰的虚析构函数

如果代码中并不会出现父类指针指向子类对象（父类引用绑定子类对象）的多态情形，那么父类中就不需要有虚析构函数。同时在开发文档中也应该明确告知开发者不应该public继承该类，而是应该尽量用private继承

如果某个类并不作为父类使用，那么父类中也不应该出现虚析构函数（以防止额外的内存开销）