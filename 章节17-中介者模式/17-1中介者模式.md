# 中介者模式（Mediator）

中介者模式也称为调停者模式。

在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，这叫作“牵一发而动全身”，非常复杂。

如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。这样的例子还有很多，例如，你刚刚参加工作想租房，可以找“房屋中介”；或者，自己刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。

在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。

## 中介者模式基本概念

中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。

中介者模式是一种对象行为型模式，其主要优点如下。

1. 类之间各司其职，符合迪米特法则。
2. 降低了对象之间的耦合性，使得对象易于独立地被复用。
3. 将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。


其主要缺点是：中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。

## 中介者模式范例引入

#### 需求如下

登录界面有 游客登录 账号登录，二者只能选其一进行登录，当选择游客登录时，账号 和 密码输入框 禁用。同时登录按钮开启，当选择账号登录时，账号和密码输入框启用，同时账号和密码都不为空的时候，，登录按钮才开启，不然任意一个为空，都禁用登录按钮，退出按钮始终开启可点击

```c++
namespace _nmsp1
{
    // UI控件的父类
    class CtlParent
    {
    public:
        CtlParent(string caption):m_caption(caption)
        {}
        
        virtual ~CtlParent() {}
        
    public:
        // 单UI控件发生变化时，该函数会被调用
        virtual void Change(std::map<string, CtlParent*>& tmpctlList) = 0;
        // 形参map中包含所有对话框中所涉及的UI控件
        
        // 设置UI控件 启用或者禁用
        virtual void Enable(bool sign) = 0;
        
    protected:
        string m_caption;   // 控件上面显示的文字内容
    };
    
    // 普通按钮相关类
    class Button : public CtlParent
    {
    public:
        Button(string caption):CtlParent(caption) {}
        
        // 设置按钮 启用或者禁用
        virtual void Enable(bool sign)
        {
            if(sign == true)
            {
                std::cout << "按钮 [" << m_caption << "]  以被启用" << std::endl;
            }
            else
            {
                std::cout << "按钮 [" << m_caption << "]  以被禁用" << std::endl;
            }
        }
        
        // 按钮被点击时 该函数会被调用
        virtual void Change(std::map<string, CtlParent*>& tmpctlList);
    };
    
    // 单选按钮相关类
    class Radio : public CtlParent
    {
    public:
        Radio(string caption):CtlParent(caption) {}
        
        // 设置单选按钮 启用或者禁用
        virtual void Enable(bool sign)
        {
            // 单选按钮用到禁用和启用
        }
        
        // 设置单选按钮被选中或者取消时的回调函数
        void Selected(bool sign)
        {
            if(sign == true)
            {
                std::cout << "单选按钮 [" << m_caption << "]  被选中" << std::endl;
            }
            else
            {
                std::cout << "单选按钮 [" << m_caption << "]  被禁用" << std::endl;
            }
        }
        
        // 单选按钮被点击时 该函数会被调用
        virtual void Change(std::map<string, CtlParent*>& tmpctlList);
    };
    
    // 输入框相关类
    class EditCtl : public CtlParent
    {
    public:
        EditCtl(string caption):CtlParent(caption) {}
        
        // 设置输入框 启用或者禁用
        virtual void Enable(bool sign)
        {
            if(sign == true)
            {
                std::cout << "输入框 [" << m_caption << "]  以被启用" << std::endl;
            }
            else
            {
                std::cout << "输入框 [" << m_caption << "]  以被禁用" << std::endl;
            }
        }
        
        // 编辑框中的内容是否为空
        bool isContentEmpty()
        {
            return m_content.empty();
        }
        
        // 编辑框中的内容发生变化时 该函数会被调用
        virtual void Change(std::map<string, CtlParent*>& tmpctlList);
        
    private:
        string m_content;       // 输入框中的内容
    };
    
    // ----------------------------------------
    // 按钮 change
    void Button::Change(std::map<string, CtlParent*>& tmpctlList)
    {
        if(m_caption == "login") // 登录按钮
        {
            std::cout << "登录中......." << std::endl;
        }
        else if(m_caption == "exit") // 退出按钮
        {
            std::cout << "退出游戏！" << std::endl;
        }
    }
    
    // 单选按钮 change
    void Radio::Change(std::map<string, CtlParent*>& tmpctlList)
    {
        if(m_caption == "visiter")    // 游客登录
        {
            (static_cast<Radio*>(tmpctlList["visiter"]))->Selected(true);   // 游客登录单选按钮被选中
            (static_cast<Radio*>(tmpctlList["count"]))->Selected(false);    // 账号登录单选按钮被禁用
        
            tmpctlList["username"]->Enable(false);  // 账号输入框被禁用
            tmpctlList["password"]->Enable(false);  // 密码输入框被禁用
            
            tmpctlList["login"]->Enable(true);      // 登录按钮设置启用
            tmpctlList["exit"]->Enable(true);       // 退出按钮设置启用
            
        }
        else if(m_caption == "count")    // 账号登录
        {
            (static_cast<Radio*>(tmpctlList["visiter"]))->Selected(false);   // 游客登录单选按钮被禁用
            (static_cast<Radio*>(tmpctlList["count"]))->Selected(true);    // 账号登录单选按钮被选中
        
            tmpctlList["username"]->Enable(true);  // 账号输入框被启用
            tmpctlList["password"]->Enable(true);  // 密码输入框被启用
            
            // 判断账密是否输入
            if(static_cast<EditCtl*>(tmpctlList["username"])->isContentEmpty() || static_cast<EditCtl*>(tmpctlList["password"])->isContentEmpty())
            {
                // 账号密码为空
                tmpctlList["login"]->Enable(false);      // 登录按钮设置禁用
            }
            else
            {
                tmpctlList["login"]->Enable(true);      // 登录按钮设置启用
            }
            tmpctlList["exit"]->Enable(true);       // 退出按钮设置启用
        }
    }
    
    // 编辑框 change
    void EditCtl::Change(std::map<string, CtlParent*>& tmpctlList)
    {
        // 判断账密是否输入
        if(static_cast<EditCtl*>(tmpctlList["username"])->isContentEmpty() || static_cast<EditCtl*>(tmpctlList["password"])->isContentEmpty())
        {
            // 账号密码为空
            tmpctlList["login"]->Enable(false);      // 登录按钮设置禁用
        }
        else
        {
            tmpctlList["login"]->Enable(true);      // 登录按钮设置启用
        }
    }
    
    void func()
    {
        // 创建各种控件
        CtlParent* visiterRadio = new Radio("visiter");
        CtlParent* countRadio = new Radio("count");
        CtlParent* usernameInput = new EditCtl("username");
        CtlParent* passwordInput = new EditCtl("password");
        CtlParent* loginBtn = new Button("login");
        CtlParent* exitBtn = new Button("exit");
        
        std::map<string, CtlParent*> uiCtlList;
        
        // 将所有创建的UI控件保存到map容器中
        uiCtlList["visiter"] = visiterRadio;
        uiCtlList["count"] = countRadio;
        uiCtlList["username"] = usernameInput;
        uiCtlList["password"] = passwordInput;
        uiCtlList["login"] = loginBtn;
        uiCtlList["exit"] = exitBtn;
        
        // 默认情况下UI状态
        (static_cast<Radio*>(uiCtlList["visiter"]))->Selected(true);
        (static_cast<Radio*>(uiCtlList["count"]))->Selected(false);
        
        uiCtlList["username"]->Enable(false);
        uiCtlList["password"]->Enable(false);
        
        uiCtlList["login"]->Enable(true);
        uiCtlList["exit"]->Enable(true);
        
        // 单选按钮 [visiter]  被选中
        // 单选按钮 [count]  被禁用
        // 输入框 [username]  以被禁用
        // 输入框 [password]  以被禁用
        // 按钮 [login]  以被启用
        // 按钮 [exit]  以被启用
        
        std::cout << "------- 模拟点击【账号登录】按钮 -------" << std::endl;
        uiCtlList["count"]->Change(uiCtlList);
        // 单选按钮 [visiter]  被禁用
        // 单选按钮 [count]  被选中
        // 输入框 [username]  以被启用
        // 输入框 [password]  以被启用
        // 按钮 [login]  以被禁用
        // 按钮 [exit]  以被启用
        
        
        // 释放资源
        for(auto iter = uiCtlList.begin(); iter != uiCtlList.end(); ++iter)
        {
            delete iter->second;
            iter->second = nullptr;
        }
    }
}
```

上面这个范例就是典型的网状设计，每个控件在发生改变的时候，直接与其他ui控件进行逻辑交互。这个时候，我们可以引入一个中介者类。由中介者来控制和协调一组对象的交互，每个对象不需要知道其他对象的存在，只需要知道中介者的存在，与中介者打交道即可

## 中介者（Mediator）模式