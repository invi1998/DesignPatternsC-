# 职责链模式（Chain Of Responsibility）

也叫做责任模式（是一种行为型模式），看起来它与传统数据结构中的链表非常类似。

在现实生活中，一个事件需要经过多个对象处理是很常见的场景。例如，采购审批流程、请假流程等。公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据需要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这无疑增加了难度。

在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；还有 [Struts2](http://c.biancheng.net/struts2/) 的拦截器、[JSP](http://c.biancheng.net/jsp/) 和 [Servlet](http://c.biancheng.net/servlet/) 的 Filter 等，所有这些，都可以考虑使用责任链模式来实现。

## 模式的定义与特点

责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

注意：责任链模式也叫职责链模式。

在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。

责任链模式是一种对象行为型模式，其主要优点如下。

1. 降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
2. 增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。
3. 增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
4. 责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。
5. 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。


其主要缺点如下。

1. 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。
2. 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
3. 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。

## 一个关于涨薪审批的范例

加薪请求

> 加薪 <= 1000, 部门经理审批
> 加薪 <= 5000, 加薪 > 1000,  技术总监审批
> 加薪 > 5000， 总经理审批

传统方法处理加薪请求

```c++
namespace _nmsp1
{
    // 薪水处理类
    class SalaryHander
    {
    public:
        // 处理加薪请求
        void raiseRequest(const string sname, int salfigure)  // 员工名， 加薪数额
        {
            if(salfigure <= 1000)
            {
                depManagerSP(sname, salfigure);
            }
            else if(salfigure <= 5000)
            {
                CTOSP(sname, salfigure);
            }
            else
            {
                CEOSP(sname, salfigure);
            }
        }
        
    private:
        // 部门经理审批加薪请求
        void depManagerSP(const string& sname, int salfigure)
        {
            std::cout << sname << " 的加薪要求为：" << salfigure << "元， 部门经理审批通过" << std::endl;
        }
        
        // 技术总监审批加薪请求
        void CTOSP(const string& sname, int salfigure)
        {
            std::cout << sname << " 的加薪要求为：" << salfigure << "元， 技术总监审批通过" << std::endl;
        }
        
        // 总经理审批加薪请求
        void CEOSP(const string& sname, int salfigure)
        {
            std::cout << sname << " 的加薪要求为：" << salfigure << "元， 总经理审批通过" << std::endl;
        }
    };
    
    void func()
    {
        SalaryHander sh;
        sh.raiseRequest("张三", 7823);
        // 张三 的加薪要求为：7823元， 总经理审批通过
        sh.raiseRequest("李四", 1200);
        // 李四 的加薪要求为：1200元， 技术总监审批通过
        sh.raiseRequest("万五", 11000);
        // 万五 的加薪要求为：11000元， 总经理审批通过
    }
}
```



## 引入职责链（Chain Of Responsibility）模式

## 单纯与非单纯的职责链模式