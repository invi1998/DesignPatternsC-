# 状态模式（State）

在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变。如人都有高兴和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。

对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理。但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。

以上问题如果采用“状态模式”就能很好地得到解决。状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。

状态模式它是一种行为型模式，它完成一个类似于有限状态机这么一个功能

## 状态模式的定义与特点

状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

状态模式是一种对象行为型模式，其主要优点如下。

1. 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。
2. 将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。
3. 状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。


状态模式的主要缺点如下。

1. 状态模式的使用必然会增加系统的类与对象的个数。
2. 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。
3. 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。

## 一个基本的状态模式范例

```c++
#include <iostream>

using namespace std;

// 有限状态机（Finite State Mache， 缩写 FSM），简称状态机
// 当某个事件（转移条件）发生时，会根据当前状态决定你执行哪种动作，然后进入下一种状态

// 情景模拟：
// 假设游戏中怪物 血量500点，
// 1）血量 > 400的点，怪物->凶悍状态，反击
// 2）血量 <= 400 && 血量 > 100, 怪物->不安状态，反击并呼唤其他怪物支援。
// 3) 血量 <= 100，怪物 -> 恐惧状态， 逃跑并不再反击
// 4）血量 <= 0， 怪物 -> 死亡状态

namespace _nmsp1
{
    // 定义怪物状态 枚举值
    enum MonsterState
    {
        MonS_Fer,       // 凶悍状态
        MonS_Vorr,      // 不安状态
        MonS_Fear,      // 恐惧状态
        MonS_Dead      // 死亡状态
    };
    
    // 怪物类
    class Monster
    {
    public:
        Monster(int life):m_life(life), m_status(MonS_Fer)
        {}
        
    public:
        // 怪物被攻击，pover表示受到的伤害（扣血多少）
        void attacked(int pover)
        {
            m_life-= pover;
            if (m_status == MonS_Fer)
            {
                if (m_life > 400)
                {
                    std::cout << "怪物受到" << pover << "点伤害，并对主角进行反击" << std::endl;
                }
                else if(m_life > 100)
                {
                    std::cout << "怪物受到" << pover << "点伤害，并对主角进行反击, 同时开始向附近怪物求援" << std::endl;
                    m_status = MonS_Vorr;
                }
                else if(m_life > 0)
                {
                    std::cout << "怪物受到" << pover << "点伤害，并停止反击, 开始逃跑" << std::endl;
                    m_status = MonS_Fear;
                }
                else
                {
                    std::cout << "怪物受到" << pover << "点伤害，死亡" << std::endl;
                    m_status = MonS_Dead;
                }
            }
            else if (m_status == MonS_Vorr)
            {
                if(m_life > 100)
                {
                    std::cout << "怪物受到" << pover << "点伤害，并对主角进行反击, 变得不安" << std::endl;
                    m_status = MonS_Vorr;
                }
                else if(m_life > 0)
                {
                    std::cout << "怪物受到" << pover << "点伤害，并停止反击, 开始逃跑" << std::endl;
                    m_status = MonS_Fear;
                }
                else
                {
                    std::cout << "怪物受到" << pover << "点伤害，死亡" << std::endl;
                    m_status = MonS_Dead;
                }
            }
            else if (m_status == MonS_Fear)
            {
                if(m_life > 0)
                {
                    std::cout << "怪物受到" << pover << "点伤害，并停止反击, 开始逃跑" << std::endl;
                    m_status = MonS_Fear;
                }
                else
                {
                    std::cout << "怪物受到" << pover << "点伤害，死亡" << std::endl;
                    m_status = MonS_Dead;
                }
            }
            else if (m_status == MonS_Dead)
            {
                std::cout << "怪物死亡" << std::endl;
            }
        }
        
    private:
        int m_life;     // 血量
        MonsterState m_status;  // 初始状态
    };
    
    void func()
    {
        Monster mon(500);
        mon.attacked(20);
        // 怪物受到20点伤害，并对主角进行反击
        mon.attacked(100);
        // 怪物受到100点伤害，并对主角进行反击, 同时开始向附近怪物求援
        mon.attacked(200);
        // 怪物受到200点�害，并对主角进行反击, 变得不安
        mon.attacked(20);
        // 怪物受到20点伤害，并对主角进行反�, 变得不安
        mon.attacked(100);
        // 怪物受到100点伤害，并停止反击, 开始逃跑
        mon.attacked(200);
        // 怪物受到200点伤害，死亡
    }
    
}

int main()
{
    _nmsp1::func();

    return 0;
}


```

## 引入状态（State）模式

## 状态类的单件实现方式