# 解释器模式（Interpreter）

在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。

虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的。

解释器模式适合对一些比较简单的文法结构进行分析。

## 模式的定义与特点

解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。

这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。

解释器模式是一种类行为型模式，其主要优点如下。

1. 扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
2. 容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。


解释器模式的主要缺点如下。

1. 执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。
2. 会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。
3. 可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。

## 一个解释器模式编写的范例

#### 情景模拟

假设存在一些变量，这些变量都用一个 字母 来表示。（a,b,c,d）

这些变量的值希望在运行时进行指定，同时希望对这些变量进行加减法运算

比如：程序运行，我们给a,b,c,d值为7,9,3,2 然后给他一个字符串“a-b+c+d”

希望程序能够进行如下运算 7-9+3+2 = 3

#### 分析：

字符串表达式是可以做任意变量之间的任意加减操作的。比如上面提到的，我们可以先算a-b.，然后将得到的结构在 +c,然后得到的结果再+d。所以这是一个从左到右的计算规则（或者从左到右的语法规则），如果将这些规则表达为一个句子，来代表a-b+c+d，然后构建一个解释器来解释这个句子。这就是解释器模式所做的事情。实质或者说难点就是如何将计算规则表达为一颗语法树【表达式树】

![](../img/impicture_20220119_141845.png)

这些表达式分为 非终结表达式（树枝-黄色）和终结表达式（树叶-红色）。语法树中的每个节点所属的类都会有一个叫做Interpreter的成员函数，用来对本节点进行解释。对于我们现在这个情景来说，解释器对树叶节点的解释操作就是直接用数值来对变量进行替换。而对于非终结表达式（黄色）所作出的解释就是，将该节点下的左操作数和右操作数进行实际的加减操作。

```c++
namespace _nmsp1
{
    // 表达式（节点）父类
    class Expression
    {
    public:
        Expression(int num, char sign):m_dgb_num(num), m_dgb_sign(sign)
        {}
        
        virtual ~Expression() {}
        
    public:
        // 解析语法树中单前节点的函数
        // map中的键值对用于保存变量名以及对应的值
        virtual int interpreter(std::map<char, int> var) = 0;
        
    public:
        // 一下两个成员变量只是为了跟踪调试，便于观察而引入
        int m_dgb_num;  // 创建该对象时的一个编号，用于记录本对象是第几个创建的
        char m_dgb_sign;    // 标记本对象类型，v代表是变量（终结表达式），+、-表示是一个非终结符表达式
        
    };
    
    // 终结符表达式 
    class VarExpression : public Expression
    {
    public:
        VarExpression(const char& key, int num, char sign):Expression(num, sign)
        {
            m_k = key;
        }
        
         virtual int interpreter(std::map<char, int> var)
         {
            return var[m_k];    // 返回该变量名对应的数值
         }
        
        
    private:
        char m_k; // 保存变量名
    };
    
    // 运算符表达式（非终结表达式）父类
    class SymbolExpression : public Expression
    {
    public:
        SymbolExpression(Expression* left, Expression* right, int num, char sign):Expression(num, sign)
        {
            m_left = left;
            m_right = right;
        }
        
        // 获取左孩子
        Expression* getLeft()
        {
            return m_left;
        }
        
        // 获取右孩子
        Expression* getRight()
        {
            return m_right;
        }
        
    protected:
    // 对于非终结表达式，左右各有一个操作数
        Expression* m_left;
        Expression* m_right;
    };
    
    // 加法运算符表达式
    class AddExpression : public SymbolExpression
    {
    public:
        AddExpression(Expression* left, Expression* right, int num, char sign):SymbolExpression(left,right,num,sign)
        {}
        
        virtual int interpreter(std::map<char, int> var)
        {
            // 递归调用左操作数interpreter方法
            int value1 = m_left->interpreter(var);
            // 递归调用右操作数interpreter方法
            int value2 = m_right->interpreter(var);
            int result = value1 + value2;
            return result;
        }
    };
    
    // 减法运算符表达式
    class SubExpression : public SymbolExpression
    {
    public:
        SubExpression(Expression* left, Expression* right, int num, char sign):SymbolExpression(left,right,num,sign)
        {}
        
        virtual int interpreter(std::map<char, int> var)
        {
            // 递归调用左操作数interpreter方法
            int value1 = m_left->interpreter(var);
            // 递归调用右操作数interpreter方法
            int value2 = m_right->interpreter(var);
            int result = value1 - value2;
            return result;
        }
    };
    
    // 创建语法树的函数
    // strExp 表示要计算的表达式的字符串
    Expression* analyse(string strExp)
    {
        std::stack<Expression*> expSatck;   // 这里用到了栈这种顺序容器
        Expression* right = nullptr;
        Expression* left = nullptr;
        int icount = 1;
        
        // 循环遍历字符串中每一个字符
        for(size_t i = 0; i < strExp.size(); ++i)
        {
            switch(strExp[i])
            {
                // 加减运算就是将计算的结果反倒栈顶，然后下一次运算的时候再从栈顶取出来
                case '+':
                    // 加法符号（非终结表达式）
                    left = expSatck.top();  // 返回栈顶元素作为左孩子
                    ++i;
                    right = new VarExpression(strExp[i], icount++, 'v');
                    // 将加法运行结果压栈处理
                    expSatck.push(new AddExpression(left, right, icount++, '+'));
                    break;
                case '-':
                    // 减法符号（非终结表达式）
                    left = expSatck.top();  // 返回栈顶元素做为左孩子
                    ++i;
                    right = new VarExpression(strExp[i], icount++, 'v');
                    // 将减法运算压栈处理
                    expSatck.push(new SubExpression(left, right, icount++, '-'));
                    break;
                default:
                    // 终结符表达式
                    expSatck.push(new VarExpression(strExp[i], icount++, 'v'));
                    // 遇到变量，压栈处理
            }
        }
        
        Expression* expression = expSatck.top();
        
        return expression;
    }
    
    // 资源释放函数 (从根节点)
    void release(Expression* expression)
    {
        // 释放表达式树的节点内存
        SymbolExpression* pSe = dynamic_cast<SymbolExpression*>(expression);
        // 此处代码有优化空间（不使用dynamic_cast）
        if(pSe)
        {
            release(pSe->getLeft());
            release(pSe->getRight());
        }
        delete expression;
    }
    
    void func()
    {
        string strExp = "a-b+c-d+e+f";
        std::map<char, int> varmap;
        // 下面给字符串表达式中每个参与运算的变量赋一个对应的数值
        varmap.insert(make_pair('a', 23));
        varmap.insert(make_pair('b', 3));
        varmap.insert(make_pair('c', 223));
        varmap.insert(make_pair('d', 3));
        varmap.insert(make_pair('e', 7));
        varmap.insert(make_pair('f', 19));
        
        // 创建语法树
        Expression* expression = analyse(strExp);
        // 调用interpreter接口求解字符串表达式的结果
        int result = expression->interpreter(varmap);
        std::cout << "字符串" << strExp << "的计算结果为：" << result << std::endl;
        // 字符串a-b+c-d+e+f的计算结果为：266
        
        // 释放资源
        release(expression);
    }
}
```

![](../img/impicture_20220119_145134.png)

## 引入解释器（Interpreter）模式

## 机器人控制器范例