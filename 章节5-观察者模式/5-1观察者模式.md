# 观察者模式（Observer）

在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；还有，当我们开车到交叉路口时，遇到红灯会停，遇到绿灯会行。这样的例子还有很多，例如，股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众、小偷与警察等。

在软件世界也是这样，例如，Excel 中的数据与折线图、饼状图、柱状图之间的关系；MVC 模式中的模型与视图的关系；事件模型中的事件源与事件处理者。所有这些，如果用观察者模式来实现就非常方便。

## 一个遍历问题导致的低效率范例

需求，新增群组功能，同一个群组内的成员可以看到成员聊天消息，非同一群组的成员不能看到群组消息

```c++
namespace _nmsp1
{
    class Fighter;  // 前向声名
    list<Fighter*> g_PlayerList;    // 玩家列表
    
    // 玩家 父类
    class Fighter
    {
    public:
        Fighter(int tmpID, string name):m_iPlayerID(tmpID), m_sPlayerName(name)
        {
            m_iFamilyID = -1;   // 表示当前玩家没有加入任何家族
        }
        
        virtual ~Fighter() {}
        
        // 为玩家设置家族ID
        void SetFamilyID(int tmpID)
        {
            m_iFamilyID = tmpID;
        }
    
    public:
        void SayWorlds(string content)  // 玩家聊天这个动作
        {
            if (m_iFamilyID != -1)
            {
                // 该玩家属于某个家族，将说的话广播通知到家族群的其他玩家
                for(auto iter = g_PlayerList.begin(); iter != g_PlayerList.end(); ++iter)
                {
                    if (m_iFamilyID == (*iter)->m_iFamilyID)
                    {
                        // 同一个家族的其他玩家也应该收到这条信息
                        NotifyWorlds((*iter), content);
                    }
                }
            }
        }
        
    private:
        // 其他玩家收到了当前玩家的聊天消息
        void NotifyWorlds(Fighter* fighter, string content)
        {
            // 显示消息
            std::cout << "玩家：" << fighter->m_sPlayerName << "    收到了玩家：" << m_sPlayerName << "     发送的聊天消息" << std::endl;
            std::cout << "聊天消息内容：" << content << std::endl;
        }
        
    private:
        int m_iPlayerID;    // 玩家ID，全局唯一
        string m_sPlayerName;   // 玩家名
        int m_iFamilyID;    // 家族ID
    };
    
    
    // 战士角色
    class F_Warrior : public Fighter
    {
    public:
        F_Warrior(int temID, string name):Fighter(temID, name)
        {}
    };
    
    // 法师角色
    class F_Mage : public Fighter
    {
    public:
        F_Mage(int temID, string name):Fighter(temID, name)
        {}
    };
    
    // 牧师角色
    class F_Priest : public Fighter
    {
    public:
        F_Priest(int temID, string name):Fighter(temID, name)
        {}
    };
}
```

main中运行测试效果

```c++
int main()
{
    // 创建游戏玩家
    _nmsp1::Fighter* play1 = new _nmsp1::F_Warrior(10, "法维安");
    _nmsp1::Fighter* play2 = new _nmsp1::F_Priest(11, "哈辛达");
    _nmsp1::Fighter* play3 = new _nmsp1::F_Mage(12, "菲奥娜");
    _nmsp1::Fighter* play4 = new _nmsp1::F_Warrior(13, "沙木亚");
    _nmsp1::Fighter* play5 = new _nmsp1::F_Mage(14, "哈比");
    _nmsp1::Fighter* play6 = new _nmsp1::F_Warrior(15, "周虹");
    _nmsp1::Fighter* play7 = new _nmsp1::F_Priest(16, "蓝焰女王");
    
    play1->SetFamilyID(100);
    play2->SetFamilyID(100);
    play3->SetFamilyID(110);
    play4->SetFamilyID(100);
    play5->SetFamilyID(140);
    play6->SetFamilyID(140);
    play7->SetFamilyID(100);
    
    _nmsp1::g_PlayerList.push_back(play1);
    _nmsp1::g_PlayerList.push_back(play2);
    _nmsp1::g_PlayerList.push_back(play3);
    _nmsp1::g_PlayerList.push_back(play4);
    _nmsp1::g_PlayerList.push_back(play5);
    _nmsp1::g_PlayerList.push_back(play6);
    _nmsp1::g_PlayerList.push_back(play7);
    
    // 当某个玩家聊天时，同家族的人都应该收到聊天消息
    play1->SayWorlds("断罪之书，终将夺回！");
    
    // 玩家：法维安    收到了��家：法维安     发送的��天消息
    // 聊天消息内容��断罪之书，终将夺回！
    // 玩家：哈辛达    收到了玩家：法维安     发送�聊天消息
    // 聊天消息内容：断罪之书，终将夺回！
    // 玩家：沙木亚    收到了玩家：法维安     发送的聊天消息
    // 聊天消息内容：断罪之书，终将夺�！
    // 玩家：蓝焰女王    收到了玩家：法维安     发送的聊天消息
    // 聊天消��内容：断罪之书，终将夺回！
    

    return 0;
}

```

当前这种代码虽然实现了聊天功能，但是试想，如果游戏中有上万个玩家，那么这里发一条消息就需要遍历上万次，程序运行效率必然低下

## 引入观察者（Observer）模式

## 应用联想